/*! ip.js by Alexandre Mercier - https://github.com/amercier/ip.js */
var IPv4={};IPv4.Address=function(address){if(typeof address!=="string"&&typeof address!=="number"){throw new Error('Expecting parameter to be a String/Number, "'+(typeof address)+'" given.')
}if(/^-?[0-9]+$/.test(address)){this.address=Number(address);if(this.address<-2147483648||this.address>2147483647){throw new Error('Invalid IPv4 address "'+this.address+'"')}}else{var ip=address.match&&address.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
if(!ip||ip[1]>255||ip[2]>255||ip[3]>255||ip[4]>255){throw new Error('Invalid IPv4 Address "'+address+'"')}this.address=(+ip[1]<<24)+(+ip[2]<<16)+(+ip[3]<<8)+(+ip[4])}};IPv4.Address.prototype.toString=function(){return((this.address>>>24)%256)+"."+((this.address>>>16)%256)+"."+((this.address>>>8)%256)+"."+((this.address>>>0)%256)
};IPv4.Address.prototype.getNext=function(){if(this.address==2147483647){return new IPv4.Address(-2147483648)}if(this.address==-1){throw new Error("IP address 255.255.255.255 has no next address")}return new IPv4.Address(this.address+1)
};IPv4.Address.prototype.getPrevious=function(){if(this.address==-2147483648){return new IPv4.Address(2147483647)}if(this.address==0){throw new Error("IP address 0.0.0.0 has no previous address")}return new IPv4.Address(this.address-1)
};IPv4.Mask=function(mask){if(/^[0-9]+$/.test(mask)){var maskSize=Number(mask);if(maskSize>32){throw new Error("Expecting mask size between 0 and 32, got "+maskSize)}this.mask=maskSize==0?0:(-1<<(32-maskSize))
}else{this.mask=(mask instanceof IPv4.Address?mask:new IPv4.Address(mask)).address}};IPv4.Mask.prototype.getMaskSize=function(){switch(this.mask){case -1:return 32;case 0:return 0;default:return Math.round(32-Math.log(~(this.mask)+1)/Math.log(2))
}};IPv4.Mask.prototype.apply=function(address){return new IPv4.Address(this.mask&(address instanceof IPv4.Address?address:new IPv4.Address(address)).address)};IPv4.Mask.prototype.toString=function(){return new IPv4.Address(this.mask).toString()
};IPv4.Subnet=function(network,mask){this.network=this.getAddressAsObject(network);this.mask=this.getMaskAsObject(mask);var networkAddress;if((networkAddress=this.mask.apply(this.network).address)!=this.network.address){throw new Error('Invalid IPv4 Subnet "'+this+'", should be "'+new IPv4.Subnet(networkAddress,mask)+'".')
}};IPv4.Subnet.prototype.getAddressAsObject=function(address){return address instanceof IPv4.Address?address:new IPv4.Address(address)};IPv4.Subnet.prototype.getMaskAsObject=function(mask){return mask instanceof IPv4.Mask?mask:new IPv4.Mask(mask)
};IPv4.Subnet.prototype.toString=function(){return this.network.toString()+"/"+this.mask.getMaskSize()};IPv4.Subnet.prototype.getBroadcastAddress=function(){return new IPv4.Address(this.network.address|~this.mask.mask)
};IPv4.Subnet.prototype.isNetworkAddress=function(address){return this.getAddressAsObject(address).address===this.network.address};IPv4.Subnet.prototype.isBroadcastAddress=function(address){return this.getAddressAsObject(address).address===this.getBroadcastAddress().address
};IPv4.Subnet.prototype.isValidAddress=function(address){var tmpAddress=this.getAddressAsObject(address);return this.mask.apply(tmpAddress).address==this.network.address&&!this.isNetworkAddress(tmpAddress)&&!this.isBroadcastAddress(tmpAddress)
};IPv4.Subnet.prototype.toPool=function(){return new IPv4.Pool(this)};IPv4.Pool=function(subnet){if(!subnet||!(subnet instanceof IPv4.Subnet)){throw new Error("Expecting parameter to be a IPv4.Subnet, "+subnet+" given.")
}this.subnet=subnet;this.allocatedAddresses=[]};IPv4.Pool.prototype.isAllocated=function(address){address=address instanceof IPv4.Address?address:new IPv4.Address(address);if(!this.subnet.isValidAddress(address)){throw new Error("The IP address "+address+" does not belong to the subnet "+this.subnet)
}for(var i=0;i<this.allocatedAddresses.length;i++){if(this.allocatedAddresses[i].address==address.address){return true}}return false};IPv4.Pool.prototype.isAvailable=function(address){address=address instanceof IPv4.Address?address:new IPv4.Address(address);
return this.subnet.isValidAddress(address)&&!this.isAllocated(address)};IPv4.Pool.prototype.allocate=function(address){var toString=String.prototype.toString;if(toString.call(address)==="[object Array]"){for(var i=0;
i<address.length;i++){var value=address[i];if(toString.call(value)==="[object Array]"){throw new Error("Nested arrays are not supported by IPv4.Pool#allocate()")}this.allocate(value)}}else{address=address instanceof IPv4.Address?address:new IPv4.Address(address);
if(!this.isAllocated(address)){this.allocatedAddresses.push(address)}}return this};IPv4.Pool.prototype.getFirstAvailable=function(){var subnet=this.subnet,first;for(first=subnet.network.getNext();first!==null&&subnet.isValidAddress(first)&&this.isAllocated(first);
first=first.getNext()){}return subnet.isValidAddress(first)?first:null};IPv4.Pool.prototype.getLastAvailable=function(){var subnet=this.subnet,last;for(last=subnet.getBroadcastAddress().getPrevious();last!==null&&subnet.isValidAddress(last)&&this.isAllocated(last);
last=last.getPrevious()){}return subnet.isValidAddress(last)?last:null};